import getBaoMiddleware from "./middleware/bao";
import getFileInfo, {} from "./utils/get-file-info";
/**
 * Type guard for ServeStaticMiddlewareOptions.
 */
function isMiddleware(options) {
    return Object.hasOwn(options, "middlewareMode");
}
/**
 * Get the correct pathname from the requested URL.
 * @param url The requested URL
 * @param stripFromPathname The string to remove from the pathname, if necessary
 */
function getPathname({ pathname }, stripFromPathname) {
    return stripFromPathname ? pathname.replace(stripFromPathname, "") : pathname;
}
/**
 * Get the normalized path to redirect to.
 * @param pathname The requested pathname
 * @param requestedFile The requested file
 * @param options The serveStatic() options
 */
async function getRedirectPath(pathname, { isFile }, { collapseSlashes, dirTrailingSlash, }) {
    let redirectPath = pathname;
    // Normalize slashes
    if (collapseSlashes) {
        const pkg = await import("./utils/collapse-slashes");
        redirectPath = pkg.collapseSlashes(redirectPath, {
            keepTrailing: redirectPath.endsWith("/"), // Preserve trailing slash if it exists
        });
    }
    // Add trailing slash
    if (dirTrailingSlash && !isFile && !redirectPath.endsWith("/")) {
        redirectPath = `${redirectPath}/`;
    }
    return redirectPath;
}
/**
 * Get the file to serve, either the requested file or the folder's index file.
 * @param pathname The requested pathname
 * @param requestedFile The requested file
 * @param root The root path
 * @param options The serveStatic() options
 * @returns The file to serve, or null if none exists
 */
async function getFileToServe(pathname, requestedFile, root, { index, dotfiles }) {
    const isDotfile = pathname.split("/").pop()?.startsWith(".");
    if (requestedFile.isFile && (!isDotfile || dotfiles === "allow")) {
        return requestedFile;
    }
    // If it is a folder and it has an index
    const indexFile = index === null ? null : await getFileInfo(`${root}/${pathname}/${index}`);
    if (indexFile?.exists && indexFile.isFile) {
        return indexFile;
    }
    return null;
}
export default function serveStatic(root, options = {}) {
    root = `${process.cwd()}/${root}`;
    const { index = "index.html", dirTrailingSlash = true, collapseSlashes = true, stripFromPathname, headers, dotfiles = "deny", defaultMimeType = "text/plain", charset = "utf-8", } = options;
    const wantsMiddleware = isMiddleware(options);
    const getResponse = async (req) => {
        const pathname = getPathname(new URL(req.url), stripFromPathname);
        const requestedFile = await getFileInfo(`${root}/${pathname}`);
        // If path does not exists, return 404
        if (!requestedFile.exists) {
            return new Response("404 Not Found", {
                status: 404,
                headers: {
                    ...headers,
                    "Content-Type": `text/plain; charset=${charset}`,
                },
            });
        }
        // Redirect to normalized path, if needed
        const redirectPath = await getRedirectPath(pathname, requestedFile, {
            collapseSlashes,
            dirTrailingSlash,
        });
        if (redirectPath !== pathname) {
            return new Response(undefined, {
                status: 308,
                headers: {
                    ...headers,
                    Location: redirectPath,
                },
            });
        }
        // Serve file or index, if one of them exists
        const fileToServe = await getFileToServe(pathname, requestedFile, root, { index, dotfiles });
        if (fileToServe) {
            return new Response(fileToServe.blob, {
                headers: {
                    ...headers,
                    "Content-Type": `${fileToServe.mimeType ?? defaultMimeType}; charset=${charset}`,
                },
            });
        }
        // Fallback to 403
        return new Response("403 Forbidden", {
            status: 403,
            headers: {
                ...headers,
                "Content-Type": `text/plain; charset=${charset}`,
            },
        });
    };
    if (wantsMiddleware) {
        const { middlewareMode, handleErrors = false } = options;
        switch (middlewareMode) {
            case "bao":
                return getBaoMiddleware(getResponse, handleErrors);
            // No default
        }
    }
    return getResponse;
}
//# sourceMappingURL=serve-static.js.map